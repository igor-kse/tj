## ![hw](https://cloud.githubusercontent.com/assets/13649199/13672719/09593080-e6e7-11e5-81d1-5cb629c438ca.png) Домашнее задание HW02

- 1: Имплементировать `InMemoryUserRepository` по аналогии с `InMemoryMealRepository` (список пользователей возвращать
  отсортированным по имени)
- 2: сделать `Meal extends BaseEntity`, `MealTo` перенести в пакет `ru.javawebinar.topjava.to` (transfer
  objects)
- 3: Изменить `MealRepository` и `InMemoryMealRepository` таким образом, чтобы вся еда всех пользователей находилась в
  одном общем хранилище, но при этом каждый конкретный аутентифицированный пользователь мог видеть и редактировать
  только свою еду.
    - 3.1: реализовать хранение еды для каждого пользователя можно с добавлением поля `userId` в `Meal` ИЛИ без него (
      как нравится). Напомню, что репозиторий один и приложение может работать одновременно с многими пользователями.
    - 3.2: если по запрошенному id еда отсутствует или чужая, возвращать `null/false` (см. комментарии в
      `MealRepository`)
    - 3.3: список еды возвращать отсортированный в обратном порядке по датам
    - 3.4: дополнительно: попробуйте сделать реализацию атомарной  (те учесть коллизии при одновременном изменении еды
      одного пользователя)
- 4: Реализовать слои приложения для функциональности "еда". API контроллера должна удовлетворять все потребности демо
  приложения и ничего лишнего (см. [демо](http://javaops-demo.ru/topjava)). Поиск и изменение порядка сортировки в
  таблице демо приложения реализованы на клиенте в браузере (плагин DataTables), сейчас делать не нужно.
    - **Смотрите на реализацию слоя для user и делаете по аналогии! Если там что-то непонятно, не надо исправлять или
      делать по своему. Задавайте вопросы. Если действительно нужна правка - я сделаю и напишу всем.**
    - 4.1: после авторизации (сделаем позднее), id авторизованного юзера можно получить из `SecurityUtil.authUserId()`.
      Запрос попадает в контроллер, методы которого будут доступны снаружи по http, т.е. запрос можно будет сделать с
      ЛЮБЫМ id для еды
      (не принадлежащем авторизированному пользователю). Нельзя позволять модифицировать/смотреть чужую еду.
    - 4.2: `SecurityUtil` может использоваться только на слое web (см. реализацию `ProfileRestController`).
      `MealService` можно тестировать без подмены логики авторизации, поэтому **в методы сервиса и репозитория мы
      передаем параметр `userId`: id авторизованного пользователя (предполагаемого владельца еды)**.
    - 4.3: если еда не принадлежит авторизированному пользователю или отсутствует, в `MealService` бросать
      `NotFoundException`.
    - 4.4: конвертацию в `MealTo` можно делать как в слое web, так и в
      service ([Mapping Entity->DTO: Controller or Service?](http://stackoverflow.com/questions/31644131))
    - 4.5: в `MealService` постараться сделать в каждом методе только одни запрос к `MealRepository`
    - 4.6 еще раз: не надо в названиях методов повторять названия класса (`Meal`).

![image](https://user-images.githubusercontent.com/13649199/121820224-66ffc480-cc9a-11eb-8abb-d1015ec2cb79.png)

- 5: включить классы еды в контекст Spring (добавить аннотации) и вызвать из `SpringMain` любой метод
  `MealRestController` (проверить что Spring все корректно заинжектил)

### Optional

- 6: в `MealServlet` сделать инициализацию Spring, достать `MealRestController` из контекста и работать с едой через
  него (**как в `SpringMain`**). `pom.xml` НЕ менять, работаем со `spring-context`. Сервлет обращается к контролеру,
  контроллер вызывает сервис, сервис - репозиторий. Когда будем работать через Spring MVC, `MealServlet` удалим,
  останется только контроллер.

----------------------------

### Итоги занятия после выполнения ДЗ:

Мы создали архитектуру нашего приложения с разделением на слои и внедрили в наш проект фреймворк Spring, который их
связывает.  
Далее мы реализовали функционал нашего приложения для работы с едой, как он сделан
в [демо приложении](http://javaops-demo.ru/topjava) (но с фиктивной аутентификацией)

---------------------

### ![error](https://cloud.githubusercontent.com/assets/13649199/13672935/ef09ec1e-e6e7-11e5-9f79-d1641c05cbe6.png) Типичные ошибки и подсказки по реализации

- 1: **В реализации `InMemoryUserRepository`**
    - 1.1: `getByEmail` попробуйте сделать через `stream`
    - 1.2: `delete` попробуйте сделать за одно обращение к map (без `containsKey`). При удалении пользователя его еду
      можно оставить, при реализации в базе будет CASCADE.
    - 1.3: при запросе списка юзеров предусмотрите случай одинаковых `User.name` (порядок должен быть зафиксированным).
      Поле `User.email`у нас уникально - в базе будет ограничение.
- 2: **В реализации `InMemoryMealRepository`**
    - 2.1: В `Meal`, которая приходит из браузера в контроллер, нет никакой информации о пользователе (еда приходит в
      контроллер **БЕЗ `user/userId`, она может быть только от авторизированного пользователя**). По id еды и
      авторизованному пользователю нужно проверить ее принадлежность (его это еда или чужая)
      **Проверьте сценарий: авторизованный пользователь пробует изменить чужую еду (id еды ему не принадлежит).**
    - 2.2: `get\update\delete` - следите, чтобы не было NPE (`NullPointException` может быть, если в хранилище
      отсутствует юзер или еда).
    - 2.3: Фильтрацию по датам сделать в репозитории т.к. из базы будем брать сразу отфильтрованные по дням записи.
      Следите чтобы **первый и последний день не были обрезаны, иначе сумма калорий будет неверная**.
    - 2.4: Если запрашивается список и он пустой, не возвращайте NULL! По пустому списку можно легко итерироваться без
      риска `NullPoinException`.
    - 2.5: Не дублируйте код в `getAll` и метод с фильтрацией
    - 2.6: попробуйте учесть, что следующая реализация (сортировка, фильтрация) будет делаться прямо в базе данных
- 3: Проверьте, что удалили `Meal.id` и связанные с ним методы (он уже есть в базовом `BaseEntity`)
- 5: **Реализация 'MealRestController' должен уметь обрабатывать запросы**:
    - 5.1: Отдать свою еду (для отображения в таблице, формат `List<MealTo>`), запрос БЕЗ параметров
    - 5.2: Отдать свою еду, отфильтрованную по startDate, startTime, endDate, endTime
    - 5.3: Отдать/удалить свою еду по id, параметр запроса - id еды. Если еда с этим id чужая или отсутствует -
      `NotFoundException`
    - 5.4: Сохранить/обновить еду, параметр запроса - Meal. Если обновляемая еда с этим id чужая или отсутствует -
      `NotFoundException`
    - 5.5: Сервлет мы удалим, а контроллер останется, поэтому возвращать `List<MealTo>` надо из контроллера. И userId
      принимать в контроллере НЕЛЬЗЯ (иначе - для чего аторизация?).
    - 5.6: В концепции REST при update дополнительно принято передавать id (см. `AdminRestController.update`)
    - 5.7: Для получения всей своей еды сделайте отдельный `getAll` без применения фильтра
- 6: Проверьте корректную обработку пустых значений date и time (в частности, если все значения пустые, должен выводится
  весь список)
- 7: `id` авторизированного пользователя получаем так: `SecurityUtil.authUserId()`, cм. `ProfileRestController`
- 8: В `MealServlet`
    - 8.1: Закрывать springContext в сервлете грамотнее всего в `HttpServlet.destroy()`: если где-то в контексте Spring
      будет ленивая инициализация, метод-фабрика, не синглтон-scope, то контекст понадобится при работе приложения. У
      нас такого нет, но делать надо все грамотно.
    - 8.2: Не храните параметры фильтра как члены класса сервлета, это не многопоточно! Один экземпляр сервлета
      используется всеми запросами на сервер, попробуйте дернуть его из 2х браузеров.
    - 8.3: В сервлете нельзя использовать `@Autowired` и `@Component`. См вопрос выше- "Почему нельзя сервлет помещать в
      Spring контекст?"